/numpai/
numeric + python
官网：www.numpy.org

array()   向量
	输入一个列表（元组？）
	属性：
		shape（行列）
		
		ndim（维度）

		引索与列表相同

zeros()  输入一个元组，一般为(n,m)，表示n*m零矩阵

ones()   全为1的矩阵


matrix() 与array的区别？它的输入参数可以是array对象

random.rand()	直接输入n,m，生成一个随机n*m的矩阵（0~1）
	randint(low,hight=none,size=none)  
		low表示取值不高于，size是一个元组表示n,m


eye()  因该是生成一个单位矩阵

	返回一个二维矩阵，在某一条对角线上全是1，其他全是0
	参数n,m=None,k=0(表示偏移主对角线行数)，datype=<class 'float'>, order='C',order读取数据的方式



diag() 输入对角元素组成的列表，生成一个对角矩阵
	参数v,k,k的意义与eye中的一样



reshape(a,newshape,order='C')  元素总数不变

			newshape=(x,y),一般其中给定一个参数可以整除n*m，另一个参数为-1
			order='C'，按行读取成一列，再按行安放到新矩阵
			order='F'，按列
			order='A'，试验一个3*5的矩阵，和C的结果一样


arange()输入一个int，生成0 — n-1个数组成的列表（一维数组）,array对象
	arange对象既有列表的索引和分片方法




#########array对象##############
多维array数组既可以当作嵌套列表一样索引和切片，它也有自己的独特方式

1.arr[a:b]  = i，表示将这一范围的全设为i


2.arr[0,1]相当于arr[0][1],arr[0,2,1:]相当于arr[0][2][1:]

3.arr[:,:,1]的含义则不同，假设arr为x*y*z三维矩阵，arr[:]可以理解为生成x个降了第一个维度的数组(y*z)
	
	arr[:,:]可以理解为对arr[:]生成的所有数组再次进行降维，生成x*y个长度为z的一维数组
	arr[:,:,1]可以理解为，在x*y的二维矩阵中，填入对应的一位数组的第2个元素	

  在此基础上可以理解arr[0,0:2,1:]

4.arr[0,::2,::2]其中::2表示指针一次挪动两行	生成二维数组

5.本质上arr[a,b,c] a,b,c其实代表了想，x,y,z三维的坐标或者区间（分片），依照这个区间（可以是点）重新构建一个array对象

6.arr[[0,0,0,0],[0,0,2,2],[0,2,0,2]] 这三个列表长度为4表示要从arr中抽取四个元素，将这四个元素的坐标

	分别放在这三个列表里，第一个列表表示x坐标，以此类推	它生成一维数组

7.arr[np.ix_()]，输入n个一维数组，将n个数组中的进行排列组合得到,比如ix_([1,3],[2,5])将得到：
	[[a[1,2],a[1,5]],[a[3,2],a[3,5]]]	它生成的维度取决于参数的个数、
	这个方法其实是按ix_()中的数组（表示每一维可取的坐标）进行排列组合后，生成每个点的坐标，
	按图索骥地拿到这个点的数值





vstack  在垂直发方向上合并数据 a=[1,2,3] b =[4,5,6] np.vstack((a,b))为[a,b]
	在行的维度上（第一阶）进行合并，其他维度必须相同




hstack 输入两个矩阵组成的元组	，在第二个维度进行合并


dstack 输入两个矩阵组成的元组	，在第三个维度进行合并


concatenate ((a,b),axis=int),轴的计算从0开始，一共有n各维度可选，axis=None，表示将其所有元素按顺序排成一个一维矩阵？


expand_dims() 扩充维度 (arr,axis=int)，axis可以取n+1各维度
	


np.mgrid[0:9,0:6]生成一个2×9×6的三位矩阵，第一行（二维向量）中的行数由0:9决定，每一列的数字相同，由0:6决定。第二行反过来
####广播机制（broadcasting）

1.多个数组之间的加减计算，以shape最长的数组为准

2.结果的shape取各个矩阵维度的最大值

3.输入数组某个轴长度相同或者为1时，这个数组才能计算

4.某一维长度为1，沿着这个维度计算，都用同一组的值


例子：
	a = np.arrange(4)
	b = np.ones(5)
	c = a.reshape(4,1)
	
	a+b报错
	b+c根据2、3,4得到一个4×5的矩阵
		
	b在运算中会自动补位，得到1×5的矩阵，貌似自动补维都是从前补



https://zhuanlan.zhihu.com/p/83122583/edit