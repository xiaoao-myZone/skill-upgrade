1. 我最大的疑问在与, 貌似子串在匹配的过程中, 它该如何记录子串中相同的已匹配过的部分(这部分既作为上一次匹配未成功字符的前缀, 也是未匹配成功字符之前存在过的)
2. 如果子串中没有相同的子串, 会如何? 那基本上最大会计算(m+n)次
3. 如果用想当然的办法最多需要m*n, 也就是p = 'aac' t='aaaaaaaac'
4. 因为子串的自我重复性, 会导致在用一般方法匹配是, 陷入陷阱
5. 而用KMP的方法很好解决这件事, 它巧妙在用一个数组记录每个字符可以跳转的位置, 这个位置的前面部分与跳转前一致(当然这样说好像也说不全)
6. 有意思的是,这个子串重复的部分必须从开头开始算, 不然这个算法没有优势, 同时如果这样, 也不会陷入4中所说的陷阱中
7. 如果算上构建这个数组的过程, 那么这个时间复杂度应该是n+2*m, m为子串长度