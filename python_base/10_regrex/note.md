# Regrex

## Flags
re.M: MULTILINE 此时 ^ 和 $ 不会被解释
re.I: IGNORECASE 忽略大小写
re.U	匹配Unicode字符集，将影响\w,\W,\B,\b,\s,\S字符类的匹配结果
re.L: LOCALE 影响 "w, "W, "b, 和 "B，这取决于当前的本地化设置
re.D: DOTALL 使 "." 特殊字符完全匹配任何字符，包括换行；没有这个标志， "." 匹配除了换行外的任何字符
re.X: VERBOSE 当该标志被指定时，在 RE 字符串中的空白符被忽略，除非该空白符在字符类中或在反斜杠之後；这可以让你更清晰地组织和缩进 RE
[python re模块中的flag问题](https://blog.csdn.net/Hk_john/article/details/78269434)


# 	group()匹配形式中的每一个括号表示一个小组，如果不输入参数，返回匹配到的字段，如果输入小组编号，则返回小组字段




## 自引用

通过\g<name>方式引用之前匹配的内容(?P < name >)


#######不匹配某个单词###############
## 案例
### 用来匹配多个strong并列，并且连续
`target = r'<strong>(.+?)</strong><((?:(?!strong).)[^>]+?)>'`

不匹配某个单词，并且多条件并列直接连在一起写就可以了

## 贪婪匹配

贪婪匹配：匹配到的字符最长（系统默认）
懒惰匹配：匹配到的字符最短

表现形式

贪婪型		懒惰型
  * *?
  + +?
  ?		  ??
 {n,}		 {n,}?


##  通配符
'.'：可以代表除换行符（\n,\r）以外的任意一字符
'+'：。。。。。。。1次或者多次，等同{1,}
'*'：前面的内容匹配0次或者任意多次，等同{0,}
'?'：。。。。。。。0次或者1次，等同{0,1}

'|'表示并列，匹配A或B，一般需要用(A|B)不然出现歧义

'(...)'

		+，*，?具有对前面的字段具有粘性，也就是说，前面的字段没有括号()或[]隔开均会当作一个整体

表示除\n以外的任意字符---在+或者*后面加？表示懒惰

## 元字符
^  _  $  \  |  @  []  {}  ()

## 字符集
[]匹配括号内的任意一个
[abcd] 任意一个
[a-z]任意一个小写
[0-9]任意一个数字
[A-Za-z0-9]英文数字任一
[^abc]非abc之外任一
等价
\d（数字）  \w（字母数字下划线）  \s(单个空格)  \D（非数字相当于[^\d]）  \W（非字符）  \S（非空格）

\A从字符串开始匹配
\Z从字符串结尾匹配
\b一个单词的开头或者结尾（\b匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)\w（匹配字母或数字或下划线或汉字）”）
\1必须与小括号配合使用

## 选择与分组
'(fr|b|f|cl)og'
分组可以理解为将匹配到的一部分内容（括号内的）返回
对应可以用groups与group（组别，缺省默认为0），对应的star\end（组别）给出组别在整个所匹配字符串中的位置
groups()以元组返回matchobj匹配内容中的组，group（0）返回所有匹配内容
(?p<name>表达式)，可以以group('name')的方式获得匹配结果

## 指定次数
｛｝
flag:标志位，是否区分大小写（re.IGNORECASE），多行匹配等

'x{5,10}'5-10次
'x{3,}'3次及以上
'x{3}'3次

## 位置锚点
 ^ 表示只从首段匹配
'^http'

 $ 表示只从尾端匹配
'rock$'


## 反向引用
&n匹配已经匹配的内容

		汉字域[\u4e00-\u9f5a]不包括中文标点

## 正则表达式中引入变量
r''+变量+''


## 模块一章遇到的问题：
[-0-9]是否为合法字符集


## 单词边界
\b
str1='i love python '
str2=re.findall(r'\bon',str1)
str3=re.findall(r'on\b',str1)
print(str2)
print(str3)



